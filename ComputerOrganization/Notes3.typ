#set page("a4")
#set heading(numbering: "1.")
#show heading: it => {
    if (it.level <= 1){
        block(it.body)
    } else if (it.level == 2) {
        block(counter(heading).display() + " " + it.body)
    } else {
        block(it.body)
    }
}

#let font = (
  main: "IBM Plex Serif",
  mono: "IBM Plex Mono",
  cjk: "Noto Serif CJK SC",
)

#show link: underline

#let qt(body) = {
  block(
    stroke: 0.5pt,
    fill: white,
    inset: 8pt,
    width: 100%,
    [#body]
  )
}

updated: 2025-09-15  

= 第二章-2

== 进制转换   
- 整数的进制转换
整数的十进制转二进制：除2取余法   \
例如： \
45 / 2 = 22 余 1  低位\
22 / 2 = 11 余 0   \
11 / 2 = 5  余 1   \
5  / 2 = 2  余 1   \
2  / 2 = 1  余 0   \
1  / 2 = 0  余 1     高位\
然后将余数倒序排列，得到二进制数：101101


也可以口算：  \
$2^5=32 (100000), 2^4=16, 2^3=8, 2^2=4, 2^1=2, 2^0=1$  \
45 = 32 + 8 + 4 + 1 = $2^5 + 2^3 + 2^2 + 2^0$ = 101101


- 小数的进制转换  
小数十进制转二进制：乘2取整法   \
例如： \
0.625 × 2 = 1.25 取整1  高位\
0.25  × 2 = 0.5  取整0   \
0.5   × 2 = 1.0  取整1  低位\
然后将整数部分依次排列，得到二进制数：0.101

#qt[
  其原理是：\
  $x = 0.a_1 a_2 a_3 ... $ （二进制）
  $= a_1 × 2^{-1} + a_2 × 2^{-2} + a_3 × 2^{-3} + ... $ \
  所以：\
  $2x = a_1.a_2 a_3 ... $ \
  取整数部分 $a_1$，小数部分继续乘2，直到 小数部分为0或达到所需精度。
]

== IEEE 754 

- IEEE 754定义

32位浮点数：｜符号（1）｜阶码（8）｜尾数（23）｜ \
64位浮点数：｜符号（1）｜阶码（11）｜尾数（52）｜

其中尾数归1化为：1.f (f为0/1串) \
阶码采用移码表示即：e = E(移) = E + 127 或 1023 （64位浮点数）

#qt[
  32位：$(-1)^S * 1.f * 2^(e-127) $ \
  64位：$(-1)^S * 1.f * 2^(e-1023) $
]

由于阶码全0和全1表示的是特殊的含义，因此阶码的有效范围是：1 ～ 254 （-126 ～ 127），1 ～ 2046 （-1022 ～ 1023）
#qt[
非规格化表示下，32位最小正数：尾数0.00...01 阶码1（-126），即 
 $2^(-23) * 2^(-126) = 2^(-149)$

所能表示的最大正整数是：
$1.1111...1 * 2^(254 - 127)$
即 $（2^24 - 1） * 2 ^ (127 - 23)$

]

- 浮点数特殊值 （要背熟）

#qt[
规格化数(SP)：阶码$1~254$ （值 $-126 ~ 127$)，尾数最高位隐含为1 \
0(阶为全0，尾为全0) \
∞(阶为全1，尾为全0) \
NaN(阶为全1，尾为非0)\
非规格化数(阶为全0，尾为非0) 
]


- 浮点数的转换

#figure(
  image("figures/2-1.png", width: 80%),
  caption: [已知十六进制（hex）,计算十进制小数],
)

#figure(
  image("figures/2-2.png", width: 80%),
  caption: [已知十进制小数，计算IEEE 754 十六进制表示],
)